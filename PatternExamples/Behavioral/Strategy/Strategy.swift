
import Foundation


// MARK: - Theory

/*
 Суть паттерна Стратегия заключается в создании отдельных классов (Стратегий), которые будут включать в себя схожие алгоритмы. В результате можно изменять функциональность объектов применением различных классов-стратегий.

 Когда применять Стратегию?
 ● Когда необходимо применять различные варианты алгоритма внутри одного объекта.
 ● Если имеется множество классов, отличающихся только некоторым поведением.
 ● Если есть необходимость ограничения алгоритма применением только к некоторым данным.
 ● Если существует условный оператор, в каждой ветке которого вызывается определенный
 алгоритм.
 
 Как применять Стратегию?
 1. Реализовать общий интерфейс для Стратегий.
 2. Реализовать необходимые Стратегии.
 3. Реализовать объект, который будет работать со Стратегиями.
 4. Инициализировать и передать объекту необходимую Стратегию.
 
 Стратегия позволяет заменять алгоритмы при выполнении программы, реализует принцип открытости/закрытости, скрывает данные алгоритма.
 Стратегия усложняет программу из-за добавления множества дополнительных классов, и разработчик, применяющий алгоритмы, должен отлично знать разницу между ними.
   
 
 
 Во время изучения данного паттерна встал вопрос, почему просто не использовать наследование с переопределением методов, тогда не придется создавать кучу протоколов, но в ходе изучения данного вопроса я пришел к выводу, что стратегия в конечно итоге более гибкий варинта и на более сложных примерах это будет прослеживатся гораздя ярче, вот хороший коммент на эту тему:
 
 Стратегия — это модель ООП, а Наследование — это принцип ООП. Стратегия реализуется с использованием (или для поддержки) наследования (фактически, обобщения интерфейса).

 наследование

 Наследование используется для достижения всех преимуществ ООП (оно в конечном итоге
 приводит к лучшей читаемости \ ремонтопригодности \ структуре кода).
 Наследование используется для формирования многих других шаблонов, а не только стратегии
 Наследование иногда является ограничением из-за его статической природы во время компиляции
 
 стратегия

 Стратегия предполагает наличие различных реализаций, которые можно заменить во время выполнения (или настроить гибко). Итак, ваш первый пример — это не стратегия.
 В общем, композиция (которая реализуется Стратегией) как способ повторного использования логики предпочтительнее наследования. Сначала это обеспечивало динамический полиморфизм. Во-вторых, у него меньше ограничений по реализации, таких как наследование нескольких классов и т. Д.
 Стратегия соответствует «некоторому изменяемому алгоритму» с точки зрения DDD, таким образом, оказывает реальное влияние на моделирование предметной области.
 Стратегия, как сам шаблон, обеспечивает язык («язык шаблонов») для общения между разработчиками.
 
 Шаблон стратегии использует композицию вместо наследования. В шаблоне стратегии поведения определяются как отдельные интерфейсы и конкретные классы, которые реализуют эти интерфейсы. Это позволяет лучше разделить поведение и класс, который использует поведение. Поведение можно изменить, не нарушая классы, которые его используют, и классы могут переключаться между поведениями, изменяя конкретную используемую реализацию, не требуя каких-либо значительных изменений кода. Поведение также может быть изменено как во время выполнения, так и во время проектирования.
 */


// MARK: - Test

class Strategy {
    
    static func testExample1Human() {
        
        var array = [Human]()
        
        let profSwimmerAndProfDiving = Human(ProffesionalDiver(), ProffesionalSwimmer())
        let profSwimmerAndNewbieDiving = Human(NewbieDiver(), ProffesionalSwimmer())
        let onlyRunHuman = Human()
        
        array.append(profSwimmerAndProfDiving)
        array.append(profSwimmerAndNewbieDiving)
        array.append(onlyRunHuman)
        
        for (numberInArray,human) in array.enumerated() {
            print("")
            print("human №\(numberInArray + 1) who can:")
            human.perormDive()
            human.performSwim()
            human.run()
        }
    }
}

// MARK: - Example №1 - Human

/* есть класс Human c определенными методами, пример dive и swim, у нас возникает ситуация, что каждый экземпляр класса может реализовывать данные методы по своему, пример: человек может быть провессиональном пловцом, но не уметь при этом нырять, а другой наоборот умеет профессионально нырять, но не умеет плавать. Но при этом они оба должны оставаться людьми. Реализуем паттерн стратегия для данного примера с помощью протоколов:
 class Human {
     
     func dive() {
         print("diving")
     }
     
     func swim() {
         print("swiming")
     }
     
     func run() {
         print("running")
     }
 }
 */


// MARK: protocols

fileprivate protocol DiveBehavior {
    func dive()
}

fileprivate protocol SwimBehavior {
    func swim()
}



// MARK: classes

fileprivate class ProffesionalDiver: DiveBehavior {
    func dive() {
        print("proffesional diving")
    }
}

fileprivate class NewbieDiver: DiveBehavior {
    func dive() {
        print("newbie diving")
    }
}

fileprivate class NonDiver: DiveBehavior {
    func dive() {
        print("non diving")
    }
}

fileprivate class ProffesionalSwimmer: SwimBehavior {
    func swim() {
        print("proffesional swimming")
    }
}

fileprivate class NonSwimmer: SwimBehavior {
    func swim() {
        print("nonSwimming")
    }
}


// MARK: Human

fileprivate class Human {
    
    var diveBehavior: DiveBehavior
    var swimBehavior: SwimBehavior
    
    ///создание стандартного человека, который вообще не подходит к воде)))
    init() {
        diveBehavior = NonDiver()
        swimBehavior = NonSwimmer()
    }
    
    init(_ db: DiveBehavior, _ sb: SwimBehavior) {
        diveBehavior = db
        swimBehavior = sb
    }
    
    
    //добираемся до каждой реализации данного метода
    
    func perormDive() {
        diveBehavior.dive()
    }
    
    func performSwim() {
        swimBehavior.swim()
    }
    
    func run() {
        print("running")
    }
}


