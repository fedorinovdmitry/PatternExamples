import UIKit

// MARK: - Theory
/*
 Легковес — это структурный паттерн проектирования, который позволяет вместить бóльшее количество объектов в отведённую оперативную память. Легковес экономит память, разделяя общее состояние объектов между собой, вместо хранения одинаковых данных в каждом объекте.
 
 Неизменяемость Легковесов
 Так как объекты легковесов будут использованы в разных контекстах, вы должны быть уверены в том, что их состояние невозможно изменить после создания. Всё внутреннее состояние легковес должен получать через параметры конструктора. Он не должен иметь сеттеров и публичных полей.

 Фабрика Легковесов
 Для удобства работы с легковесами и контекстами можно создать фабричный метод, принимающий в параметрах всё внутреннее (а иногда и внешнее) состояние желаемого объекта.
 Главная польза от этого метода в том, чтобы искать уже созданные легковесы с таким же внутренним состоянием, что и требуемое. Если легковес находится, его можно повторно использовать. Если нет — просто создаём новый. Обычно этот метод добавляют в контейнер легковесов либо создают отдельный класс-фабрику. Его даже можно сделать статическим и поместить в класс легковесов.

 Применимость
 - Когда не хватает оперативной памяти для поддержки всех нужных объектов.
  Эффективность паттерна Легковес во многом зависит от того, как и где он используется. Применяйте этот паттерн, когда выполнены все перечисленные условия:
 * в приложении используется большое число объектов;
 * из-за этого высоки расходы оперативной памяти;
 * большую часть состояния объектов можно вынести за пределы их классов;
 * большие группы объектов можно заменить относительно небольшим количеством разделяемых объектов, поскольку внешнее состояние вынесено.
 */
// MARK: - Test

class Flyweight {

    static func testExampleWithTrees() {
        
        let forest = Forest()
        
        forest.plantTree(x: 10, y: 15,
                         name: "birch",
                         color: UIColor(red: 1.0, green: 1.0, blue: 1.0, alpha: 1),
                         texture: "birch's texture")
        forest.plantTree(x: 59, y: 40,
                         name: "oak",
                         color: UIColor.brown,
                         texture: "oak's texture")
        forest.plantTree(x: 5, y: 2,
                         name: "birch",
                         color: UIColor(red: 255/255, green: 255/255, blue: 255/255, alpha: 1),
                         texture: "birch's texture")
        
        
        
        forest.draw()
        
        
    }

}

// MARK: - Example №1 -

/*
 В этом примере Легковес помогает сэкономить оперативную память при отрисовке на экране миллионов объектов-деревьев.
 Легковес выделяет повторяющуюся часть состояния из основного класса Tree и помещает его в дополнительный класс TreeType.
 Теперь, вместо хранения повторяющихся данных во всех объектах, отдельные деревья будут ссылаться на несколько общих объектов, хранящих эти данные. Клиент работает с деревьями через фабрику деревьев, которая скрывает от него сложность кеширования общих данных деревьев.
 Таким образом, программа будет использовать намного меньше оперативной памяти, что позволит отрисовать больше деревьев на экране на том же железе.
 */


// MARK: protocols


// MARK: classes

// Этот класс-легковес содержит часть полей, которые описывают
// деревья. Эти поля не уникальны для каждого дерева, в отличие,
// например, от координат: несколько деревьев могут иметь ту же
// текстуру.
//
// Поэтому мы переносим повторяющиеся данные в один-единственный
// объект и ссылаемся на него из множества отдельных деревьев.
fileprivate class TreeType {
    var name: String
    var color: UIColor
    var texture: String
    
    init(name: String, color: UIColor, texture: String) {
        self.name = name
        self.color = color
        self.texture = texture
    }
    
    func draw(x: CGFloat, y: CGFloat) {
        // 1. Создать картинку данного типа, цвета и текстуры.
        // 2. Нарисовать картинку на холсте в позиции X, Y.
        print("tree - \(name) with color - \(color.description),\n texture - \(texture) was drawed on position x(\(x)) y(\(y))")
    }
}

// Фабрика легковесов решает, когда нужно создать новый
// легковес, а когда можно обойтись существующим.
fileprivate class TreeFactory {
    static let shared = TreeFactory()
    private init() {}
    
    private var field: [TreeType] = []
    
    func getTreeType(name: String, color: UIColor, texture: String) -> TreeType {
        let treeType = field.filter{ $0.name == name && $0.color.isEqual(color) && $0.texture == texture }.first
        
        guard let tree = treeType
            else {
                let tree = TreeType(name: name, color: color, texture: texture)
                field.append(tree)
                return tree
        }
        print("use cache tree")
        return tree
    }
}

// Контекстный объект, из которого мы выделили легковес
// TreeType. В программе могут быть тысячи объектов Tree, так
// как накладные расходы на их хранение совсем небольшие — в
// памяти нужно держать всего три целых числа (две координаты и ссылка).

fileprivate class Tree {
    var x: CGFloat
    var y: CGFloat
    var type: TreeType
    
    init(x: CGFloat, y: CGFloat, type: TreeType) {
        self.x = x
        self.y = y
        self.type = type
    }
    
    func draw() {
        type.draw(x: x, y: y)
    }
    
}

// Классы Tree и Forest являются клиентами Легковеса. При
// желании их можно слить в один класс, если вам не нужно
// расширять класс деревьев далее.

fileprivate class Forest {
    private var field = [Tree]()
    
    func plantTree(x: CGFloat, y: CGFloat, name: String, color: UIColor, texture: String) {
        let type = TreeFactory.shared.getTreeType(name: name, color: color, texture: texture)
        let tree = Tree(x: x, y: y, type: type)
        field.append(tree)
    }
    
    func draw() {
        field.forEach{ $0.draw()}
    }
}

